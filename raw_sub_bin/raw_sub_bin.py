#coding=utf-8

import os
import sys
import ctypes
import struct
import math
##import sub_func
#from sub_func import *

def raw_sub_bin() :
	##	===============================================================================================
	##	ref ***commond line parameter***
	##	===============================================================================================
	##	-------------------------------------------------------------------------------------
	##	debug			调试开关，默认关闭
	##	src_path		输入文件的路径
	##	pix_format		像素格式，默认8bit
	##	subsample		处理模式，默认subsample
	##	direction		缩放方向，x y xy.默认xy
	##	skip			跳跃间隔，默认2
	##	color			是否是color，默认是color
	##	width			输入图像的宽度
	##	height			输入图像的高度
	##	resolution_list	输入图像的分辨率
	##	-------------------------------------------------------------------------------------
	debug 			= 0;
	src_path		= 0;
	pix_format		= 8;
	subsample		= 1;
	direction		= "xy";
	skip			= 2;
	color			= 1;
	width			= 0;
	height			= 0;
	resolution_list	= [];

	##	-------------------------------------------------------------------------------------
	##	循环查找参数
	##	-------------------------------------------------------------------------------------
	for i in range(0,len(sys.argv)):
		if(sys.argv[i]=="-d"):
			debug		= 1;
		if(sys.argv[i]=="-f"):
			src_path	= sys.argv[i+1];
		if(sys.argv[i]=="-p"):
			pix_format	= int(sys.argv[i+1]);
		if(sys.argv[i]=="-i"):
			for j in range(1,len(sys.argv)-i):
				if(sys.argv[i+j][0]=="-"):
					break;
				else:
					resolution_list.append(int(sys.argv[i+j]));
		if(sys.argv[i]=="-b"):
			subsample	= 0;
		if(sys.argv[i]=="-r"):
			if(sys.argv[i+1]=="x"):
				direction	= "x";
			elif(sys.argv[i+1]=="y"):
				direction	= "y";
			elif(sys.argv[i+1]=="xy"):
				direction	= "xy";
		if(sys.argv[i]=="-k"):
			skip	= int(sys.argv[i+1]);
		if(sys.argv[i]=="-m"):
			color		= 0;

	##	-------------------------------------------------------------------------------------
	##	从命令行中获得像素格式
	##	-------------------------------------------------------------------------------------
	if(pix_format<=8):
		pix_format	= 8;
	elif(pix_format>8 & pix_format<=16):
		pix_format	= 16;
	else:
		pix_format	= 32;
	##	-------------------------------------------------------------------------------------
	##	每个像素占用多少个byte
	##	-------------------------------------------------------------------------------------
	pix_byte	= pix_format/8;

	##	-------------------------------------------------------------------------------------
	##	从列表中提取宽高和roi信息
	##	-------------------------------------------------------------------------------------
	width		= resolution_list[0];
	height		= resolution_list[1];

	##	===============================================================================================
	##	判断skip是否符合分辨率的要求
	##	===============================================================================================
	skip_x	= 1;
	skip_y	= 1;

	##	-------------------------------------------------------------------------------------
	##	分别提取xy方向的skip的参数
	##	-------------------------------------------------------------------------------------
	if(direction=="x" or direction=="xy"):
		skip_x	= skip;
	if(direction=="y" or direction=="xy"):
		skip_y	= skip;
	##	-------------------------------------------------------------------------------------
	##	检查宽高是否能被skip整除
	##	-------------------------------------------------------------------------------------
	if(color==0):
		if(width%skip_x!=0):
			print("skip_x is not valid");
			return 0;
	else:
		if(width%(skip_x*2)!=0):
			print("skip_x is not valid");
			return 0;

	if(height%skip_y!=0):
		print("skip_y is not valid");
		return 0;

	##	===============================================================================================
	##	ref ***file operation***
	##	===============================================================================================
	##	-------------------------------------------------------------------------------------
	##	判断输入的是否是一个文件
	##	--如果不是文件，打印错误，退出
	##	--如果是一个文件，打开文件
	##	-------------------------------------------------------------------------------------
	if(os.path.isfile(src_path)==False):	return -1
	if(debug==1):	print("src_path is really exist");
	infile	= open(src_path,"rb")

	##	===============================================================================================
	##	ref ***read file***
	##	===============================================================================================
	##	-------------------------------------------------------------------------------------
	##	把图像读到内存之中，方便处理，减少与硬盘交互的时间
	##	-------------------------------------------------------------------------------------
	pixel_list	= [];
	##	-------------------------------------------------------------------------------------
	##	外层循环-高度
	##	-------------------------------------------------------------------------------------
	for i in range(0, height):
		##	-------------------------------------------------------------------------------------
		##	内层循环-宽度
		##	-------------------------------------------------------------------------------------
		for j in range(0, width):
			##	-------------------------------------------------------------------------------------
			##	第一步，获取一个像素的数据
			##	1byte unsigned char
			##	2byte unsigned short
			##	4byte unsigned int
			##	-------------------------------------------------------------------------------------
			if(pix_byte==1):
				(pixel,)	 = struct.unpack("B",infile.read(1));
			elif(pix_byte==2):
				(pixel,)	 = struct.unpack("H",infile.read(2));
			elif(pix_byte==4):
				(pixel,)	 = struct.unpack("I",infile.read(4));
			pixel_list.append(pixel);

	##	-------------------------------------------------------------------------------------
	##	output list 是输出图像的列表
	##	-------------------------------------------------------------------------------------
	output_list	= [];
	##	===============================================================================================
	##	ref ***subsample***
	##	===============================================================================================
	if(subsample==1):
		##	-------------------------------------------------------------------------------------
		##	subsample mono
		##	-------------------------------------------------------------------------------------
		if(color==0):
			##	-------------------------------------------------------------------------------------
			##	外层循环-高度
			##	-------------------------------------------------------------------------------------
			for i in range(0, int(height/skip_y)):
				##	-------------------------------------------------------------------------------------
				##	内层循环-宽度
				##	-------------------------------------------------------------------------------------
				for j in range(0, int(width/skip_x)):
					output_list.append(pixel_list[i*skip_y*width+j*skip_x])
		##	-------------------------------------------------------------------------------------
		##	subsample color
		##	-------------------------------------------------------------------------------------
		else:
			##	-------------------------------------------------------------------------------------
			##	外层循环-高度
			##	-------------------------------------------------------------------------------------
			for i in range(0, int(height/skip_y)):
				##	-------------------------------------------------------------------------------------
				##	bayer格式，垂直的2个像素不能分开，故两行都要做一次操作
				##	bayer格式，水平的2个像素不能分开，故两列都要做一次操作
				##	-------------------------------------------------------------------------------------
				if(i%2==0):
					##	-------------------------------------------------------------------------------------
					##	内层循环-宽度
					##	-------------------------------------------------------------------------------------
					for j in range(0, int(width/skip_x)):
						if(j%2==0):
							##	-------------------------------------------------------------------------------------
							##	第i行，两个像素
							##	-------------------------------------------------------------------------------------
							output_list.append(pixel_list[i*skip_y*width+j*skip_x])
							output_list.append(pixel_list[i*skip_y*width+j*skip_x+1])
				##	-------------------------------------------------------------------------------------
				##	此处是bayer矩形的第二行
				##	-------------------------------------------------------------------------------------
				if((i-1)%2==0):
					##	-------------------------------------------------------------------------------------
					##	内层循环-宽度
					##	-------------------------------------------------------------------------------------
					for j in range(0, int(width/skip_x)):
						if(j%2==0):
							##	-------------------------------------------------------------------------------------
							##	第i行，两个像素
							##	-------------------------------------------------------------------------------------
							output_list.append(pixel_list[(i-1)*skip_y*width+width+j*skip_x])
							output_list.append(pixel_list[(i-1)*skip_y*width+width+j*skip_x+1])
	##	===============================================================================================
	##	ref ***binning***
	##	===============================================================================================
	pixel	= 0;
	pixel1	= 0;
	if(subsample==0):
		##	-------------------------------------------------------------------------------------
		##	binning mono
		##	-------------------------------------------------------------------------------------
		if(color==0):
			##	-------------------------------------------------------------------------------------
			##	外层循环-高度
			##	-------------------------------------------------------------------------------------
			for i in range(0, int(height/skip_y)):
				##	-------------------------------------------------------------------------------------
				##	内层循环-宽度
				##	-------------------------------------------------------------------------------------
				for j in range(0, int(width/skip_x)):
					pixel	= 0;
					##	-------------------------------------------------------------------------------------
					##	将矩阵内的数据累加
					##	-------------------------------------------------------------------------------------
					for k in range(0,skip_y):
						for l in range(0,skip_x):
							pixel	= pixel + pixel_list[i*skip_y*width+k*width+j*skip_x+l];
					##	-------------------------------------------------------------------------------------
					##	数据取平均值
					##	-------------------------------------------------------------------------------------
					pixel	= int(pixel/(skip_y*skip_x));
					output_list.append(pixel)

		##	-------------------------------------------------------------------------------------
		##	binning color
		##	-------------------------------------------------------------------------------------
		else:
			##	-------------------------------------------------------------------------------------
			##	外层循环-高度
			##	-------------------------------------------------------------------------------------
			for i in range(0, int(height/skip_y)):
				##	-------------------------------------------------------------------------------------
				##	bayer格式，垂直的2个像素不能分开，故两行都要做一次操作
				##	bayer格式，水平的2个像素不能分开，故两列都要做一次操作
				##	-------------------------------------------------------------------------------------
				if(i%2==0):
					##	-------------------------------------------------------------------------------------
					##	内层循环-宽度
					##	-------------------------------------------------------------------------------------
					for j in range(0, int(width/skip_x)):
						if(j%2==0):
							pixel	= 0;
							pixel1	= 0;
							##	-------------------------------------------------------------------------------------
							##	将矩阵内的数据累加
							##	-------------------------------------------------------------------------------------
							for k in range(0,skip_y):
								for l in range(0,skip_x):
									pixel	= pixel + pixel_list[i*skip_y*width+k*2*width+j*skip_x+l*2];
									pixel1	= pixel1 + pixel_list[i*skip_y*width+k*2*width+j*skip_x+l*2+1];
							##	-------------------------------------------------------------------------------------
							##	数据取平均值
							##	-------------------------------------------------------------------------------------
							pixel	= int(pixel/(skip_x*skip_y));
							pixel1	= int(pixel1/(skip_x*skip_y));
							##	-------------------------------------------------------------------------------------
							##	第i行，两个像素
							##	-------------------------------------------------------------------------------------
							output_list.append(pixel)
							output_list.append(pixel1)
				##	-------------------------------------------------------------------------------------
				##	此处是bayer矩形的第二行
				##	-------------------------------------------------------------------------------------
				if((i-1)%2==0):
					##	-------------------------------------------------------------------------------------
					##	内层循环-宽度
					##	-------------------------------------------------------------------------------------
					for j in range(0, int(width/skip_x)):
						if(j%2==0):
							pixel	= 0;
							pixel1	= 0;
							##	-------------------------------------------------------------------------------------
							##	将矩阵内的数据累加
							##	-------------------------------------------------------------------------------------
							for k in range(0,skip_y):
								for l in range(0,skip_x):
									pixel	= pixel + pixel_list[(i-1)*skip_y*width+width+k*2*width+j*skip_x+l*2];
									pixel1	= pixel1 + pixel_list[(i-1)*skip_y*width+width+k*2*width+j*skip_x+l*2+1];
							##	-------------------------------------------------------------------------------------
							##	数据取平均值
							##	-------------------------------------------------------------------------------------
							pixel	= int(pixel/(skip_x*skip_y));
							pixel1	= int(pixel1/(skip_x*skip_y));
							##	-------------------------------------------------------------------------------------
							##	第i行，两个像素
							##	-------------------------------------------------------------------------------------
							output_list.append(pixel)
							output_list.append(pixel1)

#	for eachpix in pixel_list:
#		print(eachpix);

	##	===============================================================================================
	##	ref ***输出文件***
	##	===============================================================================================
	##	-------------------------------------------------------------------------------------
	##	从源文件的路径得到目的文件路径
	##	-------------------------------------------------------------------------------------
	temp = os.path.split(src_path);
	only_path = temp[0];
	only_name = temp[1];
	if(only_name.rindex(".")!=-1):
		only_name	= only_name[0:only_name.rindex(".")];
#	print("only_path is ",only_path);
#	print("only_name is ",only_name);

	if(subsample==1):
		sub	= "sub";
	else:
		sub	= "bin";

	radix	= str(skip_x)+'x'+str(skip_y);

	path = only_path+'\\'+only_name+'_'+sub+'_'+radix+".raw";

	##	-------------------------------------------------------------------------------------
	##	建立新的文件
	##	-------------------------------------------------------------------------------------
	outfile	= open(path,"wb+");

	##	-------------------------------------------------------------------------------------
	##	写入新的文件
	##	-------------------------------------------------------------------------------------
	for eachpix in output_list:
		if(pix_byte==1):
			write_data	 = struct.pack("B",eachpix);
		elif(pix_byte==2):
			write_data	 = struct.pack("H",eachpix);
		elif(pix_byte==4):
			write_data	 = struct.pack("I",eachpix);
		outfile.write(write_data);

	##	===============================================================================================
	##	ref ***结束***
	##	===============================================================================================
	outfile.close()



raw_sub_bin()
