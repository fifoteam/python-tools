#coding=utf-8

import os
import sys
import ctypes
import struct
import math
##import sub_func
#from sub_func import *

def raw_get_thresh() :
	##	===============================================================================================
	##	ref ***commond line parameter***
	##	===============================================================================================
	##	-------------------------------------------------------------------------------------
	##	debug			调试开关，默认关闭
	##	src_path		输入文件的路径
	##	pix_format		像素格式，默认8bit
	##	-------------------------------------------------------------------------------------
	debug 			= 0;
	src_path		= 0;
	pix_format		= 8;

	##	-------------------------------------------------------------------------------------
	##	循环查找参数
	##	-------------------------------------------------------------------------------------
	for i in range(0,len(sys.argv)):
		if(sys.argv[i]=="-d"):
			debug		= 1;
		if(sys.argv[i]=="-f"):
			src_path	= sys.argv[i+1];
		if(sys.argv[i]=="-p"):
			pix_format	= int(sys.argv[i+1]);

	##	-------------------------------------------------------------------------------------
	##	从命令行中获得像素格式
	##	-------------------------------------------------------------------------------------
	if(pix_format<=8):
		pix_format	= 8;
	elif(pix_format>8 & pix_format<=16):
		pix_format	= 16;
	else:
		pix_format	= 32;
	##	-------------------------------------------------------------------------------------
	##	每个像素占用多少个byte
	##	-------------------------------------------------------------------------------------
	pix_byte	= pix_format/8;

	##	===============================================================================================
	##	ref ***file operation***
	##	===============================================================================================
	##	-------------------------------------------------------------------------------------
	##	判断输入的是否是一个文件
	##	--如果不是文件，打印错误，退出
	##	--如果是一个文件，打开文件
	##	-------------------------------------------------------------------------------------
	if(os.path.isfile(src_path)==False):	return -1
	if(debug==1):	print("src_path is really exist");
	infile	= open(src_path,"rb")

	##	===============================================================================================
	##	ref ***read file***
	##	===============================================================================================
	##	-------------------------------------------------------------------------------------
	##	把图像读到内存之中，方便处理，减少与硬盘交互的时间
	##	-------------------------------------------------------------------------------------
	pixel_list	= [];

	##	-------------------------------------------------------------------------------------
	##	计算图像大小，进而得出像素个数
	##	-------------------------------------------------------------------------------------
	file_size		= os.path.getsize(src_path);
	pixel_num		= int(file_size/pix_byte);

	pixel_sum		= 0;
	pixel_max		= 0;
	pixel_min		= 0;
	pixel_aver		= 0;
	##	-------------------------------------------------------------------------------------
	##	循环读图像
	##	-------------------------------------------------------------------------------------
	for i in range(0, pixel_num):
		##	-------------------------------------------------------------------------------------
		##	第一步，获取一个像素的数据
		##	1byte unsigned char
		##	2byte unsigned short
		##	4byte unsigned int
		##	-------------------------------------------------------------------------------------
		if(pix_byte==1):
			(pixel,)	 = struct.unpack("B",infile.read(1));
		elif(pix_byte==2):
			(pixel,)	 = struct.unpack("H",infile.read(2));
		elif(pix_byte==4):
			(pixel,)	 = struct.unpack("I",infile.read(4));

		pixel_list.append(pixel);

		##	-------------------------------------------------------------------------------------
		##	像素累加值
		##	-------------------------------------------------------------------------------------
		pixel_sum	= pixel_sum + pixel_list[i];

	##	-------------------------------------------------------------------------------------
	##	像素最大值
	##	-------------------------------------------------------------------------------------
	pixel_max	= max(pixel_list);

	##	-------------------------------------------------------------------------------------
	##	像素最小值
	##	-------------------------------------------------------------------------------------
	pixel_min	= min(pixel_list);

	##	-------------------------------------------------------------------------------------
	##	像素平均值
	##	-------------------------------------------------------------------------------------
	pixel_aver	= pixel_sum/pixel_num;

	##	===============================================================================================
	##	ref ***otsu threshold***
	##	===============================================================================================
	##	-------------------------------------------------------------------------------------
	##	otsu 阈值算法描述：
	##	最大类间方差法是由日本学者大津于1979年提出的,是一种自适应的阈值确定的方法,又叫大津法,简称OTSU。
	##	它是按图像的灰度特性,将图像分成背景和目标2部分。背景和目标之间的类间方差越大,说明构成图像的2部分的差别越大,
	##	当部分目标错分为背景或部分背景错分为目标都会导致2部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。
	##	-------------------------------------------------------------------------------------
	##	-------------------------------------------------------------------------------------
	##	名称标记
	##	1.前景(即目标)和背景的分割阈值记作t
	##	2.属于前景的像素点数占整幅图像的比例记为ω0,其平均灰度μ0
	##	3.背景像素点数占整幅图像的比例为ω1,其平均灰度为μ1
	##	4.图像的总平均灰度记为μ,类间方差记为g。
	##	5.图像的大小为M×N
	##	6.图像中像素的灰度值小于阈值t的像素个数记作N0
	##	7.图像中像素的灰度值大于阈值t的像素个数记作N1
	##	-------------------------------------------------------------------------------------
	##	-------------------------------------------------------------------------------------
	##	公式
	##	1.ω0=N0/M×N
	##	2.ω1=N1/M×N
	##	3.N0+N1=M×N
	##	4.ω0+ω1=1
	##	5.μ=ω0*μ0+ω1*μ1
	##	6.g=ω0(μ0-μ)^2+ω1(μ1-μ)^2
	##	将式(5)代入式(6),得到等价公式: g=ω0ω1(μ0-μ1)^2 (7)
	##	采用遍历的方法得到使类间方差最大的阈值T,即为所求。
	##	-------------------------------------------------------------------------------------
	##	-------------------------------------------------------------------------------------
	##	首先将最大的类间方差和阈值置零
	##	-------------------------------------------------------------------------------------
	gmax	= 0;
	tmax	= 0;

	back_num	= 1;
	front_num	= 1;
	##	-------------------------------------------------------------------------------------
	##	阈值在像素的最小值和最大值之间遍历
	##	-------------------------------------------------------------------------------------
	for t in range(int(math.ceil(pixel_min)),int(pixel_max)):
		##	-------------------------------------------------------------------------------------
		##	将t插入到列表当中
		##	-------------------------------------------------------------------------------------
		pixel_list.append(t);
		##	-------------------------------------------------------------------------------------
		##	升序排列
		##	-------------------------------------------------------------------------------------
		pixel_list.sort();
		##	-------------------------------------------------------------------------------------
		##	由于是升序排列，因此t的位置就是小于t值的个数
		##	-------------------------------------------------------------------------------------
		back_num	= pixel_list.index(t);
		front_num	= pixel_num-back_num;

		w1	= back_num/pixel_num;
		w0	= 1-w1;
		##	-------------------------------------------------------------------------------------
		##	删除t值，恢复列表
		##	-------------------------------------------------------------------------------------
		pixel_list.remove(t);

		##	-------------------------------------------------------------------------------------
		##	调试
		##	-------------------------------------------------------------------------------------
		if(debug==1):
			print("t is "+str(t)+"");
			print("pixel_min is "+str(pixel_min)+"");
			print("pixel_max is "+str(pixel_max)+"");
			print("back_num is "+str(back_num)+"");
			print("front_num is "+str(front_num)+"");
			print("pixel_num is "+str(pixel_num)+"");

		##	-------------------------------------------------------------------------------------
		##	计算背景区域的平均值
		##	-------------------------------------------------------------------------------------
		pixel_sum	= 0;
		for i in range(0,back_num):
			pixel_sum	= pixel_sum + pixel_list[i];
		if(back_num==0):
			u1	= 0;
		else:
			u1	= pixel_sum/back_num;

		##	-------------------------------------------------------------------------------------
		##	根据公式5，逆推出目标区域的平均值
		##	-------------------------------------------------------------------------------------
		u0	= (pixel_aver-w1*u1)/w0;

		##	-------------------------------------------------------------------------------------
		##	计算背景和目标区域的类间方差
		##	-------------------------------------------------------------------------------------
		g	= w0*w1*math.pow((u0-u1),2);

		##	-------------------------------------------------------------------------------------
		##	比较，得出最大方差
		##	-------------------------------------------------------------------------------------
		if(g>gmax):
			gmax	= g;
			tmax	= t;

	##	===============================================================================================
	##	ref ***output***
	##	===============================================================================================
	print(""+str(tmax)+"");


raw_get_thresh()
